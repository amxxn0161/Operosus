import * as pdfjs from 'pdfjs-dist';
import mammoth from 'mammoth';

// Set the PDF.js worker path
pdfjs.GlobalWorkerOptions.workerSrc = '/pdf.worker.min.js';

// Type for extracted content
export interface ExtractedContent {
  personalValues: {
    proudOf: string[];
    achievement: string[];
    happiness: string[];
    inspiration: string[];
  };
  productivityConnection: {
    coreValues: string;
    valueImpact: string;
  };
  goals: {
    description: string;
    impact: string[];
  };
  workshopOutput: {
    actions: string[];
    reflections: string;
  };
}

// Parse PDF document
export const parsePdfDocument = async (file: File): Promise<string> => {
  try {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjs.getDocument({ data: arrayBuffer }).promise;
    let fullText = '';

    for (let i = 1; i <= pdf.numPages; i++) {
      const page = await pdf.getPage(i);
      const textContent = await page.getTextContent();
      const pageText = textContent.items
        .map((item: any) => item.str)
        .join(' ');
      fullText += pageText + '\n';
    }

    return fullText;
  } catch (error) {
    console.error('Error parsing PDF:', error);
    throw new Error('Failed to parse PDF document');
  }
};

// Parse Word document
export const parseWordDocument = async (file: File): Promise<string> => {
  try {
    const arrayBuffer = await file.arrayBuffer();
    const result = await mammoth.extractRawText({ arrayBuffer });
    return result.value;
  } catch (error) {
    console.error('Error parsing Word document:', error);
    throw new Error('Failed to parse Word document');
  }
};

// Implement document content mapping
export const mapContentToWorksheet = (content: string): ExtractedContent => {
  // Extract data from the document content
  const result: ExtractedContent = {
    personalValues: {
      proudOf: ['', '', ''],
      achievement: ['', '', ''],
      happiness: ['', '', ''],
      inspiration: ['', '', ''],
    },
    productivityConnection: {
      coreValues: '',
      valueImpact: '',
    },
    goals: {
      description: '',
      impact: ['', '', ''],
    },
    workshopOutput: {
      actions: ['', '', '', '', ''],
      reflections: '',
    },
  };

  try {
    // Process the document content by looking for sections and table content
    const contentLines = content.split(/\r?\n/).filter(line => line.trim().length > 0);
    
    // Log the content for debugging
    console.log('Document content lines:', contentLines);

    // First, try to extract content from key sections by looking for specific headers
    
    // Check for "PRODUCTIVITY SUPERHERO WORKSHEET" which indicates the table format
    const hasTableFormat = contentLines.some(line => 
      line.includes('PRODUCTIVITY SUPERHERO WORKSHEET') || 
      (line.includes('PRODUCTIVITY') && line.includes('WORKSHEET')) ||
      // Additional patterns to detect table format
      line.includes('1. Creating genuine') ||
      line.includes('1.Creating genuine') ||
      (line.includes('What am I most proud of?') && 
       contentLines.some(l => l.includes('What did it take for me to achieve those things?')))
    );

    if (hasTableFormat) {
      console.log('Detected table format document');
      // Use table-specialized extraction for the document that has table format
      extractFromTableFormat(contentLines, result);
    } else {
      // Standard extraction for regular documents (non-table format)
      
      // Extract "What am I most proud of?" section
      const proudOfItems = extractItemsAfterHeading(contentLines, 'What am I most proud of?', 3);
      if (proudOfItems.length > 0) {
        result.personalValues.proudOf = proudOfItems;
      }
      
      // Extract "What did it take for me to achieve those things?" section
      const achievementItems = extractItemsAfterHeading(contentLines, 'What did it take for me to achieve those things?', 3);
      if (achievementItems.length > 0) {
        result.personalValues.achievement = achievementItems;
      }
      
      // Extract "What makes me happiest in life?" section
      const happinessItems = extractItemsAfterHeading(contentLines, 'What makes me happiest in life?', 3);
      if (happinessItems.length > 0) {
        result.personalValues.happiness = happinessItems;
      }
      
      // Extract "Who do I find inspiring...and then, what are the qualities I am admiring?" section
      const inspirationItems = extractItemsAfterHeading(contentLines, 'Who do I find inspiring', 3);
      if (inspirationItems.length > 0) {
        result.personalValues.inspiration = inspirationItems;
      }
    }
    
    // Extract "MY VALUES - what matters most to me?" section
    const valuesContent = extractContentBetweenHeadings(contentLines, 'MY VALUES - what matters most to me?', 'MY PRODUCTIVITY');
    if (valuesContent) {
      result.productivityConnection.coreValues = valuesContent.join('\n');
    }
    
    // Extract "MY PRODUCTIVITY - how does it link to my values?" section
    const productivityContent = extractContentBetweenHeadings(contentLines, 'MY PRODUCTIVITY - how does it link to my values?', 'When I become more effective');
    if (productivityContent) {
      // Skip the header line if it exists
      const valueImpactContent = extractContentAfterHeading(contentLines, 'When I become more effective');
      if (valueImpactContent) {
        result.productivityConnection.valueImpact = valueImpactContent.join('\n');
      }
    }
    
    // Extract goals description from "What will be different for you?" section
    const goalsDescription = extractContentAfterHeading(contentLines, 'What will be different for you?');
    if (goalsDescription) {
      result.goals.description = goalsDescription.join('\n');
    }
    
    // Extract goals impact from different sections
    const feelingContent = extractContentAfterHeading(contentLines, 'How will you feel?');
    if (feelingContent) {
      result.goals.impact[0] = feelingContent.join('\n');
    }
    
    const benefitsContent = extractContentAfterHeading(contentLines, 'Who benefits?');
    if (benefitsContent) {
      result.goals.impact[1] = benefitsContent.join('\n');
    }
    
    const productivityGoalContent = extractContentAfterHeading(contentLines, 'I want to improve');
    if (productivityGoalContent) {
      result.goals.impact[2] = productivityGoalContent.join('\n');
    }
    
    // Extract workshop actions
    const actionsContent = extractItemsAfterHeading(contentLines, 'WORKSHOP ONE ACTIONS / COMMITMENTS', 5);
    if (actionsContent.length > 0) {
      result.workshopOutput.actions = actionsContent;
    }
    
    // Extract reflections
    const reflectionsContent = extractContentAfterHeading(contentLines, 'What am I learning?');
    if (reflectionsContent) {
      result.workshopOutput.reflections = reflectionsContent.join('\n');
    }
  } catch (error) {
    console.error('Error mapping document content:', error);
  }
  
  return result;
};

// Function to extract content from table formatted documents
function extractFromTableFormat(lines: string[], result: ExtractedContent): void {
  try {
    // STEP 1: Find all the major section indexes in the document
    const sectionIndexes = {
      personalValues: -1,
      proudOf: -1,
      achievement: -1,
      happiness: -1,
      inspiration: -1,
      myValues: -1,
      myProductivity: -1,
      myGoals: -1
    };
    
    // Find indexes of all major sections
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Personal Values section 
      if (line.includes('MY PERSONAL VALUES') || 
          line.includes('PERSONAL VALUES') || 
          line.includes('Finding meaning and importance')) {
        sectionIndexes.personalValues = i;
      }
      
      // Proud of section
      if (line.includes('What am I most proud of?')) {
        sectionIndexes.proudOf = i;
      }
      
      // Achievement section
      if (line.includes('What did it take for me to achieve those things?')) {
        sectionIndexes.achievement = i;
      }
      
      // Happiness section
      if (line.includes('What makes me happiest in life?')) {
        sectionIndexes.happiness = i;
      }
      
      // Inspiration section
      if (line.includes('Who do I find inspiring') || line.includes('qualities I am admiring')) {
        sectionIndexes.inspiration = i;
      }
      
      // My Values section
      if (line.includes('MY VALUES') || line.includes('what matters most to me')) {
        sectionIndexes.myValues = i;
      }
      
      // My Productivity section
      if (line.includes('MY PRODUCTIVITY') || line.includes('link to my values')) {
        sectionIndexes.myProductivity = i;
      }
      
      // My Goals section
      if (line.includes('MY GOALS') || line.includes('what do I want to achieve')) {
        sectionIndexes.myGoals = i;
      }
    }
    
    // STEP 2: Extract content from each section
    
    // Get "What am I most proud of?" items
    if (sectionIndexes.proudOf >= 0) {
      const proudOfItems = extractNumberedItems(lines, sectionIndexes.proudOf, 3);
      if (proudOfItems.some(item => item.trim().length > 0)) {
        result.personalValues.proudOf = proudOfItems;
      }
      console.log('Extracted proud of items:', proudOfItems);
    }
    
    // Get "What did it take for me to achieve those things?" items
    if (sectionIndexes.achievement >= 0) {
      const achievementItems = extractNumberedItems(lines, sectionIndexes.achievement, 3);
      if (achievementItems.some(item => item.trim().length > 0)) {
        result.personalValues.achievement = achievementItems;
      }
      console.log('Extracted achievement items:', achievementItems);
    }
    
    // Get "What makes me happiest in life?" items
    if (sectionIndexes.happiness >= 0) {
      const happinessItems = extractNumberedItems(lines, sectionIndexes.happiness, 3);
      if (happinessItems.some(item => item.trim().length > 0)) {
        result.personalValues.happiness = happinessItems;
      }
      console.log('Extracted happiness items:', happinessItems);
    }
    
    // Get "Who do I find inspiring..." items
    if (sectionIndexes.inspiration >= 0) {
      const inspirationItems = extractNumberedItems(lines, sectionIndexes.inspiration, 3);
      if (inspirationItems.some(item => item.trim().length > 0)) {
        result.personalValues.inspiration = inspirationItems;
      }
      console.log('Extracted inspiration items:', inspirationItems);
    }
    
    // STEP 3: Extract MY VALUES content
    if (sectionIndexes.myValues >= 0) {
      const endIndex = findNextMajorSectionIndex(lines, sectionIndexes.myValues, [
        sectionIndexes.myProductivity, 
        sectionIndexes.myGoals
      ]);
      
      const coreValuesContent = [];
      const startIdx = sectionIndexes.myValues + 1;
      const endIdx = endIndex > 0 ? endIndex : Math.min(startIdx + 20, lines.length);
      
      for (let i = startIdx; i < endIdx; i++) {
        const line = lines[i].trim();
        if (line.length > 0) {
          coreValuesContent.push(line);
        }
      }
      
      if (coreValuesContent.length > 0) {
        result.productivityConnection.coreValues = coreValuesContent.join('\n');
      }
      console.log('Extracted core values:', coreValuesContent);
    }
    
    // STEP 4: Extract MY PRODUCTIVITY content
    if (sectionIndexes.myProductivity >= 0) {
      const endIndex = findNextMajorSectionIndex(lines, sectionIndexes.myProductivity, [
        sectionIndexes.myGoals
      ]);
      
      const productivityContent = [];
      const startIdx = sectionIndexes.myProductivity + 1;
      const endIdx = endIndex > 0 ? endIndex : Math.min(startIdx + 20, lines.length);
      
      for (let i = startIdx; i < endIdx; i++) {
        const line = lines[i].trim();
        if (line.length > 0) {
          productivityContent.push(line);
        }
      }
      
      if (productivityContent.length > 0) {
        result.productivityConnection.valueImpact = productivityContent.join('\n');
      }
      console.log('Extracted productivity content:', productivityContent);
    }
    
    // STEP 5: Process additional sections for goals and workshop outputs
    processAdditionalSections(lines, result);
    
    console.log('Extracted content from table format:', result);
  } catch (error) {
    console.error('Error extracting from table format:', error);
  }
}

// Helper to find the index of the next major section
function findNextMajorSectionIndex(lines: string[], currentIndex: number, possibleIndexes: number[]): number {
  // Filter out negative indexes and find the smallest one
  const validIndexes = possibleIndexes.filter(idx => idx > currentIndex);
  if (validIndexes.length > 0) {
    return Math.min(...validIndexes);
  }
  
  // If no valid indexes from the list, find the next heading
  return findNextSectionIndex(lines, currentIndex);
}

// Process additional sections that might be in the document
function processAdditionalSections(lines: string[], result: ExtractedContent): void {
  // Create a map of section keywords to their corresponding result property handlers
  const sectionHandlers = [
    { 
      keywords: ['What will be different for you'],
      handler: (content: string[]) => { result.goals.description = content.join('\n'); } 
    },
    { 
      keywords: ['How will you feel'],
      handler: (content: string[]) => { if (result.goals.impact.length > 0) result.goals.impact[0] = content.join('\n'); } 
    },
    { 
      keywords: ['Who benefits'],
      handler: (content: string[]) => { if (result.goals.impact.length > 1) result.goals.impact[1] = content.join('\n'); } 
    },
    { 
      keywords: ['I want to improve', 'improve my productivity'],
      handler: (content: string[]) => { if (result.goals.impact.length > 2) result.goals.impact[2] = content.join('\n'); } 
    },
    { 
      keywords: ['WORKSHOP ONE ACTIONS', 'WORKSHOP ACTIONS', 'ACTIONS / COMMITMENTS'],
      handler: (content: string[]) => { 
        // For action items, we want to extract up to 5 numbered or bullet items
        const actionItems = [];
        for (const line of content) {
          if (actionItems.length >= 5) break;
          
          // Skip header lines and short content
          if (isHeading(line) || line.length < 5) continue;
          
          // Add the line as an action item if it has substantial content
          if (line.length > 10) {
            // Clean the line of any bullet/number markers
            const cleanedLine = line.replace(/^\d+\.?\s*/, '').replace(/^[•\-*]\s*/, '').trim();
            if (cleanedLine.length > 0) {
              actionItems.push(cleanedLine);
            }
          }
        }
        
        // Ensure we have exactly 5 items
        while (actionItems.length < 5) {
          actionItems.push('');
        }
        
        result.workshopOutput.actions = actionItems.slice(0, 5);
      } 
    },
    { 
      keywords: ['What am I learning'],
      handler: (content: string[]) => { result.workshopOutput.reflections = content.join('\n'); } 
    }
  ];
  
  // Scan through the document to find these sections
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (line.length === 0) continue;
    
    // Check if this line matches any of our section keywords
    for (const section of sectionHandlers) {
      if (section.keywords.some(keyword => line.includes(keyword))) {
        // Extract content until the next section header
        const content = extractTextUntilNextHeader(lines, i + 1);
        if (content.length > 0) {
          // Call the appropriate handler function
          section.handler(content);
        }
        break; // Found a match, no need to check other keywords
      }
    }
  }
}

// Helper to extract text content until we hit the next section header
function extractTextUntilNextHeader(lines: string[], startIndex: number): string[] {
  const content = [];
  
  for (let i = startIndex; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Stop if we hit what looks like a new section header
    if (i > startIndex && (isHeading(line) || line.includes('?'))) {
      break;
    }
    
    // Add non-empty content lines
    if (line.length > 0) {
      content.push(line);
    }
  }
  
  return content;
}

// Helper function to find the index of the next section heading
function findNextSectionIndex(lines: string[], currentIndex: number): number {
  for (let i = currentIndex + 1; i < lines.length; i++) {
    const line = lines[i].trim();
    // Check if this line looks like a section header
    if (isHeading(line) || 
        line.includes('?') || 
        /^[A-Z\s]{5,}/.test(line)) { // Lines with 5+ uppercase characters are likely headers
      return i;
    }
  }
  return -1; // No next section found
}

// Helper function to extract numbered items from a specific starting index
function extractNumberedItems(lines: string[], startIndex: number, maxItems: number): string[] {
  const items: string[] = [];
  
  // Look for content in a more flexible way
  // First, get the next section index to know where to stop looking
  const nextSectionIndex = findNextSectionIndex(lines, startIndex);
  const searchEndIndex = nextSectionIndex > 0 ? nextSectionIndex : Math.min(startIndex + 50, lines.length);
  
  // We'll look through all the lines between this section header and the next
  const relevantLines = lines.slice(startIndex + 1, searchEndIndex);
  
  // Store the text that might be associated with numbered items (1., 2., 3., etc.)
  const numberedContentMap = new Map<number, string>();
  
  // First pass: look for explicitly numbered items (1., 2., 3., etc.)
  for (const line of relevantLines) {
    const trimmedLine = line.trim();
    
    // Skip empty lines and likely headers
    if (trimmedLine.length === 0 || isHeading(trimmedLine)) continue;
    
    // Check for a leading number pattern: '1.', '2.', etc.
    const numberMatch = trimmedLine.match(/^(\d+)\.?\s+/);
    if (numberMatch) {
      const itemNumber = parseInt(numberMatch[1], 10);
      if (itemNumber > 0 && itemNumber <= maxItems) {
        // Extract the content after the number
        const content = trimmedLine.replace(/^\d+\.?\s*/, '').trim();
        if (content.length > 0) {
          numberedContentMap.set(itemNumber, content);
        }
      }
    }
  }
  
  // Second pass: look for significant content blocks if we didn't find enough numbered items
  if (numberedContentMap.size < maxItems) {
    let currentItemNumber = 1;
    
    // Find substantive content blocks that aren't just numbers or very short phrases
    for (const line of relevantLines) {
      const trimmedLine = line.trim();
      
      // Skip empty lines, headers, and already processed numbered items
      if (trimmedLine.length === 0 || 
          isHeading(trimmedLine) || 
          trimmedLine.match(/^\d+\.?\s+/)) {
        continue;
      }
      
      // Check if this is substantial content
      if (trimmedLine.length > 15) {
        // Make sure we don't already have this item number
        while (numberedContentMap.has(currentItemNumber) && currentItemNumber <= maxItems) {
          currentItemNumber++;
        }
        
        // If we still have room for more items, add this content
        if (currentItemNumber <= maxItems) {
          numberedContentMap.set(currentItemNumber, trimmedLine);
          currentItemNumber++;
        }
        
        // If we've filled all item slots, stop
        if (currentItemNumber > maxItems) {
          break;
        }
      }
    }
  }
  
  // Final pass: look for content associated with item numbers based on position
  // This handles cases where the UI might show numbers but the extracted text doesn't include them
  if (numberedContentMap.size < maxItems) {
    // Calculate roughly how many lines we'd expect between items based on document structure
    const totalRelevantLines = relevantLines.length;
    const expectedLinesPerItem = Math.max(1, Math.floor(totalRelevantLines / maxItems));
    
    // Use positional information to assign content to item numbers
    for (let i = 0; i < relevantLines.length; i++) {
      const line = relevantLines[i].trim();
      
      // Skip empty, very short lines, headers, and already processed numbered items
      if (line.length < 10 || 
          isHeading(line) || 
          line.match(/^\d+\.?\s+/)) {
        continue;
      }
      
      // Determine which item number this content might belong to based on position
      const estimatedItemNumber = Math.floor(i / expectedLinesPerItem) + 1;
      if (estimatedItemNumber <= maxItems && !numberedContentMap.has(estimatedItemNumber)) {
        numberedContentMap.set(estimatedItemNumber, line);
      }
    }
  }
  
  // Convert the map to an array preserving order
  for (let i = 1; i <= maxItems; i++) {
    items.push(numberedContentMap.get(i) || '');
  }
  
  // Ensure we have exactly the right number of items
  return items.slice(0, maxItems);
}

// Helper function to extract items following a heading pattern
function extractItemsAfterHeading(lines: string[], heading: string, maxItems: number): string[] {
  const items: string[] = [];
  let foundHeading = false;
  let itemCount = 0;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    if (!foundHeading && line.includes(heading)) {
      foundHeading = true;
      continue;
    }
    
    if (foundHeading) {
      // Look for numbered items or bullet points
      if (line.match(/^\d+\./) || line.match(/^•/) || line.startsWith('-')) {
        // Clean the line by removing the number/bullet
        const cleanedLine = line.replace(/^\d+\./, '').replace(/^•/, '').replace(/^-/, '').trim();
        if (cleanedLine) {
          items.push(cleanedLine);
          itemCount++;
          
          if (itemCount >= maxItems) {
            break;
          }
        }
      } else if (itemCount > 0 && line.trim() && !isHeading(line)) {
        // This looks like a continuation of the previous item
        items[itemCount - 1] += ' ' + line.trim();
      } else if (isHeading(line)) {
        // We've hit the next heading, so stop
        break;
      }
    }
  }
  
  // Pad array to ensure we have the right number of items
  while (items.length < maxItems) {
    items.push('');
  }
  
  return items;
}

// Helper function to extract content between two headings
function extractContentBetweenHeadings(lines: string[], startHeading: string, endHeading: string): string[] | null {
  const content: string[] = [];
  let foundStart = false;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    if (!foundStart && line.includes(startHeading)) {
      foundStart = true;
      continue; // Skip the heading line
    }
    
    if (foundStart) {
      if (line.includes(endHeading)) {
        break;
      }
      
      // Skip if this is another heading
      if (!isHeading(line)) {
        content.push(line.trim());
      }
    }
  }
  
  return content.length > 0 ? content : null;
}

// Helper function to extract content after a heading
function extractContentAfterHeading(lines: string[], heading: string): string[] | null {
  const content: string[] = [];
  let foundHeading = false;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    if (!foundHeading && line.includes(heading)) {
      foundHeading = true;
      continue; // Skip the heading line
    }
    
    if (foundHeading) {
      // Stop if we hit another heading
      if (isHeading(line) && !line.includes(heading)) {
        break;
      }
      
      content.push(line.trim());
    }
  }
  
  return content.length > 0 ? content : null;
}

// Helper to check if a line is a heading
function isHeading(line: string): boolean {
  // Look for patterns that might indicate a heading
  return (
    /^MY [A-Z]+/.test(line) || // Matches "MY VALUES", "MY GOALS", etc.
    /^WORKSHOP [A-Z]+/.test(line) || // Matches "WORKSHOP ONE", etc.
    /^\d+\.\s+[A-Z]+/.test(line) || // Matches "1. PLAN", etc.
    line.includes('?') // Questions often serve as section headings
  );
}

// Main function to handle document upload and parsing
export const handleDocumentUpload = async (file: File): Promise<ExtractedContent> => {
  try {
    let documentText = '';
    
    if (file.type === 'application/pdf') {
      documentText = await parsePdfDocument(file);
    } else if (
      file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || 
      file.type === 'application/msword'
    ) {
      documentText = await parseWordDocument(file);
    } else {
      throw new Error('Unsupported file type. Please upload a PDF or Word document.');
    }
    
    // Add debugging logs to see the document text
    console.log('Document text sample (first 500 chars):', documentText.substring(0, 500));
    
    // First try using our table extraction approach
    const contentLines = documentText.split(/\r?\n/).filter(line => line.trim().length > 0);
    const tableExtracted = extractPersonalValuesTable(contentLines);
    
    // If we got values from the table extraction, use those values
    const extractedContent = mapContentToWorksheet(documentText);
    
    // If table extraction worked, override the personal values with the extracted ones
    if (tableExtracted) {
      console.log('Using table-extracted personal values');
      extractedContent.personalValues = tableExtracted;
    }
    
    // Add detailed logging of what was extracted
    console.log('EXTRACTION RESULTS:', {
      personalValues: {
        proudOf: extractedContent.personalValues.proudOf,
        achievement: extractedContent.personalValues.achievement,
        happiness: extractedContent.personalValues.happiness,
        inspiration: extractedContent.personalValues.inspiration
      },
      productivityConnection: extractedContent.productivityConnection,
      goals: extractedContent.goals,
      workshopOutput: extractedContent.workshopOutput
    });
    
    return extractedContent;
  } catch (error) {
    console.error('Error processing document:', error);
    throw error;
  }
};

// Helper function to extract personal values table data format
function extractPersonalValuesTable(lines: string[]): { 
  proudOf: string[],
  achievement: string[],
  happiness: string[],
  inspiration: string[] 
} | null {
  try {
    // Initialize result structure
    const result = {
      proudOf: ['', '', ''],
      achievement: ['', '', ''],
      happiness: ['', '', ''],
      inspiration: ['', '', '']
    };
    
    console.log('Starting table extraction with', lines.length, 'lines');
    
    // Define question indicators to identify sections
    const questionIndicators = {
      proudOf: /what am i most proud of\??/i,
      achievement: /what did it take for me to achieve those things\??/i,
      happiness: /what makes me happiest in life\??/i,
      inspiration: /who do i find inspiring|qualities i am admiring/i
    };
    
    // Find indexes of section headers in the document
    const questionIndexes: Record<string, number> = {
      proudOf: -1,
      achievement: -1,
      happiness: -1, 
      inspiration: -1
    };
    
    // Find all question positions
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].toLowerCase();
      
      if (questionIndicators.proudOf.test(line)) {
        questionIndexes.proudOf = i;
        console.log(`Found "What am I most proud of?" at line ${i}: "${lines[i]}"`);
      }
      else if (questionIndicators.achievement.test(line)) {
        questionIndexes.achievement = i;
        console.log(`Found "What did it take...?" at line ${i}: "${lines[i]}"`);
      }
      else if (questionIndicators.happiness.test(line)) {
        questionIndexes.happiness = i;
        console.log(`Found "What makes me happiest...?" at line ${i}: "${lines[i]}"`);
      }
      else if (questionIndicators.inspiration.test(line)) {
        questionIndexes.inspiration = i;
        console.log(`Found "Who do I find inspiring...?" at line ${i}: "${lines[i]}"`);
      }
    }
    
    // Track processed lines to avoid duplicates
    const processedLineIndices = new Set<number>();
    
    // Detect if we're dealing with a table format with numbered items for each section
    const sectionBasedNumbering = (
      questionIndexes.proudOf >= 0 && 
      questionIndexes.achievement >= 0 && 
      questionIndexes.happiness >= 0 &&
      questionIndexes.inspiration >= 0 &&
      // Check if sections appear in sequence
      [questionIndexes.proudOf, questionIndexes.achievement, 
       questionIndexes.happiness, questionIndexes.inspiration].every((idx, i, arr) => 
        i === 0 || idx > arr[i-1])
    );
    
    // Function to extract items from a given section using proximity to section heading
    const extractContentFromSection = (sectionIdx: number, maxItems: number = 3): string[] => {
      if (sectionIdx < 0) return ['', '', ''];
      
      const items: string[] = Array(maxItems).fill('');
      let itemCount = 0;
      
      // Skip the question line itself
      let startIdx = sectionIdx + 1;
      
      // Find the next section to determine where to stop
      const nextSectionIndices = Object.values(questionIndexes)
        .filter(idx => idx > sectionIdx)
        .sort((a, b) => a - b);
      
      const endIdx = nextSectionIndices.length > 0 
        ? nextSectionIndices[0] 
        : Math.min(startIdx + 20, lines.length);
      
      console.log(`Looking for content in section at line ${sectionIdx} from lines ${startIdx} to ${endIdx-1}`);
      
      // First pass: look for explicitly numbered items (1., 2., 3., etc.)
      for (let i = startIdx; i < endIdx; i++) {
        if (processedLineIndices.has(i)) continue;
        
        const line = lines[i].trim();
        if (line.length < 5) continue;
        
        // Skip if the line contains another question
        if (Object.values(questionIndicators).some(pattern => pattern.test(line.toLowerCase()))) {
          continue;
        }
        
        // Look for numbered items (1., 2., 3., etc.)
        const numberMatch = line.match(/^(\d+)[.)\s]+\s*(.*)/);
        if (numberMatch) {
          const number = parseInt(numberMatch[1], 10);
          const content = numberMatch[2].trim();
          
          if (number >= 1 && number <= maxItems && content.length > 0) {
            items[number-1] = content;
            processedLineIndices.add(i);
            itemCount++;
            console.log(`Found numbered item ${number} in section: "${content}"`);
          }
        }
        // For unnumbered substantial content
        else if (line.length > 10 && !line.includes('?')) {
          const emptyIndex = items.findIndex(item => !item);
          if (emptyIndex >= 0) {
            items[emptyIndex] = line;
            processedLineIndices.add(i);
            itemCount++;
            console.log(`Found unnumbered content in section: "${line}"`);
          }
        }
        
        if (itemCount >= maxItems) break;
      }
      
      return items;
    };
    
    // If we have clear section headings, try to extract content directly from each section
    if (sectionBasedNumbering) {
      console.log('Document has clear section headings - extracting content by section');
      
      // Extract content from each section
      const proudOfItems = extractContentFromSection(questionIndexes.proudOf);
      if (proudOfItems.some(item => item.length > 0)) {
        result.proudOf = proudOfItems;
        console.log('Extracted proud of items by section:', proudOfItems);
      }
      
      const achievementItems = extractContentFromSection(questionIndexes.achievement);
      if (achievementItems.some(item => item.length > 0)) {
        result.achievement = achievementItems;
        console.log('Extracted achievement items by section:', achievementItems);
      }
      
      const happinessItems = extractContentFromSection(questionIndexes.happiness);
      if (happinessItems.some(item => item.length > 0)) {
        result.happiness = happinessItems;
        console.log('Extracted happiness items by section:', happinessItems);
      }
      
      const inspirationItems = extractContentFromSection(questionIndexes.inspiration);
      if (inspirationItems.some(item => item.length > 0)) {
        result.inspiration = inspirationItems;
        console.log('Extracted inspiration items by section:', inspirationItems);
      }
    }
    
    // If we couldn't extract from sections or we're missing values, try to identify content from overall structure
    if (!result.proudOf.some(v => v) || 
        !result.achievement.some(v => v) || 
        !result.happiness.some(v => v) || 
        !result.inspiration.some(v => v)) {
      
      console.log('Trying table-structure based extraction');
      
      // Analyze all potential content items in the document
      const allContentItems: Array<{
        index: number, 
        number: number | null, 
        text: string
      }> = [];
      
      // Find all numbered and substantial content lines
      for (let i = 0; i < lines.length; i++) {
        if (processedLineIndices.has(i)) continue;
        
        const line = lines[i].trim();
        if (line.length < 10) continue;
        
        // Skip question headings
        if (Object.values(questionIndicators).some(pattern => pattern.test(line.toLowerCase()))) {
          continue;
        }
        
        // Check if it's a numbered item
        const numberMatch = line.match(/^(\d+)[.)\s]+\s*(.*)/);
        if (numberMatch) {
          const number = parseInt(numberMatch[1], 10);
          const text = numberMatch[2].trim();
          
          if (number >= 1 && number <= 3 && text.length > 0) {
            allContentItems.push({
              index: i,
              number,
              text
            });
            console.log(`Found numbered content item ${number}: "${text}"`);
          }
        } 
        // If not numbered but substantial content
        else if (line.length > 15 && !line.match(/^[A-Z\s]{5,}$/) && !line.includes('?')) {
          allContentItems.push({
            index: i,
            number: null,
            text: line
          });
          console.log(`Found substantial content: "${line}"`);
        }
      }
      
      // Sort items by their position in the document
      allContentItems.sort((a, b) => a.index - b.index);
      
      // Try to determine if we have a 2x2 grid structure
      // This needs to be determined from the actual content, not hardcoded
      
      // See if we can infer a grid structure from item positions
      const hasGridStructure = allContentItems.length >= 6;
      
      if (hasGridStructure) {
        console.log(`Detected potential table grid structure with ${allContentItems.length} items`);
        
        // For a document with content in a predictable order, map items to fields
        // This avoids hardcoding specific text patterns
        
        // Calculate how many items belong to each section
        const itemsPerSection = Math.ceil(allContentItems.length / 4);
        
        // We'll map groups of items to each section
        const sections = [
          result.proudOf,
          result.achievement,
          result.happiness,
          result.inspiration
        ];
        
        // Distribute items across sections
        for (let sectionIndex = 0; sectionIndex < 4; sectionIndex++) {
          const sectionItems = sections[sectionIndex];
          const startItemIndex = sectionIndex * itemsPerSection;
          
          for (let i = 0; i < itemsPerSection && i < 3; i++) {
            const itemIndex = startItemIndex + i;
            if (itemIndex < allContentItems.length) {
              const item = allContentItems[itemIndex];
              
              // If the item is numbered, use the number as position
              // Otherwise just put it in sequence
              const position = item.number !== null ? item.number - 1 : i;
              
              if (position >= 0 && position < 3) {
                sectionItems[position] = item.text;
                console.log(`Mapped content to section ${sectionIndex+1}, position ${position+1}: "${item.text}"`);
              }
            }
          }
        }
      }
    }
  
    // If we still have fields out of order, look for specific patterns to help
    // with reorganization, but avoid hardcoding specific text strings
    
    // Define pattern categories to identify content types by their characteristics
    const contentPatterns = {
      proudOf: [
        /creat(ing|e)/i,
        /achiev(e|ing|ed)/i,
        /volunteer/i,
        /family|friend/i,
        /career|professional/i,
        /success/i
      ],
      achievement: [
        /hard work/i,
        /consistent|consistency/i,
        /resilience|persistent/i,
        /commit(ment|ted)/i,
        /accountab(ility|le)/i,
        /focus/i,
        /learn(ing)?/i
      ],
      happiness: [
        /quiet|peaceful/i,
        /reflect(ion|ing)/i,
        /nature/i,
        /laugh(ter)?/i,
        /conversation/i,
        /people I care/i,
        /personal growth/i,
        /purpose/i,
        /life('s)?/i
      ],
      inspiration: [
        /mentor/i,
        /admire(d)?/i,
        /leader/i,
        /friend/i,
        /creativ(e|ity)/i,
        /positiv(e|ity)/i,
        /determination/i,
        /inspire(d|s)?/i
      ]
    };
    
    // Function to score a piece of text against pattern categories
    const scoreContentType = (text: string): Record<string, number> => {
      const scores: Record<string, number> = {
        proudOf: 0,
        achievement: 0,
        happiness: 0,
        inspiration: 0
      };
      
      // For each category, count pattern matches
      for (const [category, patterns] of Object.entries(contentPatterns)) {
        for (const pattern of patterns) {
          if (pattern.test(text)) {
            scores[category] += 1;
          }
        }
      }
      
      return scores;
    };
    
    // Check if fields appear to be swapped based on content patterns
    let fieldsNeedSwapping = false;
    
    // Score the content of each field
    for (const field of Object.keys(result) as Array<keyof typeof result>) {
      for (const item of result[field]) {
        if (!item) continue;
        
        const scores = scoreContentType(item);
        const highestCategory = Object.entries(scores)
          .sort((a, b) => b[1] - a[1])
          .filter(([_, score]) => score > 0)[0]?.[0];
        
        // If highest scoring category isn't current field and score is significant
        if (highestCategory && highestCategory !== field && scores[highestCategory] > 1) {
          console.log(`Item "${item.substring(0, 30)}..." in ${field} matches better with ${highestCategory}`);
          fieldsNeedSwapping = true;
        }
      }
    }
    
    // If fields appear to be swapped, try to fix the mapping
    if (fieldsNeedSwapping) {
      console.log('Content appears to be in wrong fields, attempting to reorganize');
      
      // Check if proudOf and achievement need swapping
      const proudOfScore = result.proudOf
        .map(item => scoreContentType(item || '').achievement)
        .reduce((sum, score) => sum + score, 0);
        
      const achievementScore = result.achievement
        .map(item => scoreContentType(item || '').proudOf)
        .reduce((sum, score) => sum + score, 0);
      
      // If these fields appear to be swapped based on content scoring
      if (proudOfScore > 1 && achievementScore > 1) {
        console.log('Swapping proudOf and achievement based on content analysis');
        const temp = [...result.proudOf];
        result.proudOf = [...result.achievement];
        result.achievement = temp;
      }
      
      // Check if happiness and inspiration need swapping
      const happinessScore = result.happiness
        .map(item => scoreContentType(item || '').inspiration)
        .reduce((sum, score) => sum + score, 0);
        
      const inspirationScore = result.inspiration
        .map(item => scoreContentType(item || '').happiness)
        .reduce((sum, score) => sum + score, 0);
      
      // If these fields appear to be swapped based on content scoring
      if (happinessScore > 1 && inspirationScore > 1) {
        console.log('Swapping happiness and inspiration based on content analysis');
        const temp = [...result.happiness];
        result.happiness = [...result.inspiration];
        result.inspiration = temp;
      }
    }
    
    // Final cleanup: remove duplicates and ensure we have no more than 3 items per field
    const allContent = new Set<string>();
    
    // Process each field to ensure no duplicates
    for (const field of Object.keys(result) as Array<keyof typeof result>) {
      const fieldItems = result[field];
      
      for (let i = 0; i < fieldItems.length; i++) {
        const content = fieldItems[i];
        
        if (content && content.length > 0) {
          // If we've seen this content before, remove it
          if (allContent.has(content)) {
            console.log(`Removing duplicate from ${field}[${i}]: "${content}"`);
            fieldItems[i] = '';
          } else {
            allContent.add(content);
          }
        }
      }
    }
    
    // Ensure all arrays have exactly 3 items
    for (const field of Object.keys(result) as Array<keyof typeof result>) {
      while (result[field].length < 3) result[field].push('');
      result[field] = result[field].slice(0, 3);
    }
    
    console.log('Final table extraction results:', JSON.stringify(result, null, 2));
    
    // Return the result if we have any content
    const hasContent = Object.values(result).some(arr => arr.some(item => item.length > 0));
    return hasContent ? result : null;
  } catch (error) {
    console.error('Error extracting personal values table:', error);
    return null;
  }
} 